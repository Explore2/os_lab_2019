Задание 1

1) Каждый процесс в Linux имеет свой идентификатор, называемый PID. 
Перед тем, как выполнить остановку процесса, нужно определить его PID.
Когда известен PID процесса, мы можем убить его командой kill. 
Команда kill принимает в качестве параметра PID процесса. 
Вообще команда kill предназначена для посылки сигнала процессу. 
По умолчанию, если мы не указываем какой сигнал посылать, посылается сигнал SIGTERM (от слова termination — завершение). 
SIGTERM указывает процессу на то, что необходимо завершиться. 
Сигнал SIGTERM может и не остановить процесс (например, при перехвате или блокировке сигнала), 
SIGKILL же выполняет уничтожение процесса всегда, так как его нельзя перехватить или проигнорировать.

2)pid_t waitpid(pid_t pid, int *status, int options);
Функция wait приостанавливает выполнение текущего процесса до тех пор, 
пока дочерний процесс не завершится, или до появления сигнала, который либо завершает текущий процесс,
либо требует вызвать функцию-обработчик. 
Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")),
то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются.
Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, 
указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, 
который либо завершает текущий процесс либо требует вызвать функцию-обработчик. 
Если указанный дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), 
то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются. 
Значение options создается путем логического сложения нескольких следующих констант:
WNOHANG
означает немедленное возвращение управления, если ни один дочерний процесс не завершил выполнение.

3)Системный вызов signal() устанавливает новый обработчик сигнала с номером signum в соответствии с параметром 
sighandler, который может быть функцией пользователя
SIGALRM (от англ. signal и alarm — тревога) — применяемый в POSIX-системах сигнал по истечении времени, 
предварительно заданного функцией alarm()
SIGALRM посылается ядром через целое количество секунд после вызова alarm()

4)unsigned int alarm(unsigned int seconds);
Системный вызов alarm выполняет в вызвавший его процесс доставку сигнала " SIGALRM через seconds секунд.
Если seconds равно нулю, то никаких новых тревожных сигналов в очередь поставлено не будет.

Задание 2
1) Каждый процесс может запускать дочерние процессы с помощью функции fork. 
Такие процессы остаются под контролем родительского процесса и не могут быть завершены без его ведома. 
Если один из дочерних процессов всё же завершился, а его родительский процесс не смог получить об этом 
информацию, то такой дочерний процесс становится зомби.
Зомби процессы Linux не выполняются и убить их нельзя, даже с помощью sigkill, 
они продолжают висеть в памяти, пока не будет завершён их родительский процесс.

Задание 3
1)Адреса этих символов соответствуют концам различных программных сегментов:
etext
Первый адрес за концом сегмента текста (кода программы).
edata
Первый адрес за концом сегмента инициализированных данных.
end
Первый адрес за концом сегмента неинициализированных данных (сегмента BSS).

Задание 5
1)Создания нового процесса — дорогостоящее удовольствие для ОС. 
Даже учитывая оптимизацию за счет копирования при записи, системные вызовы fork и exec создают 
новые копии страниц памяти и списка файловых описателей. 
В целом ядро ОС может создать новый поток на порядок быстрее, чем новый процесс.

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start)(void *), void *arg);

Первый параметр вызова pthread_create() является адресом для
хранения идентификатора создаваемого потока типа pthread_t.

Аргумент start является указателем на потоковую void * функцию, 
принимающей бестиповый указатель в качестве единственной переменной.

Аргумент arg — это бестиповый указатель, содержащий аргументы потока. 
Чаще всего arg указывает на глобальную или динамическую переменную, 
но если вызываемая функция не требует наличия аргументов, то в качестве arg можно указать NULL.

Аргумент attr также является бестиповым указателем атрибутов потока pthread_attr_t. 
Если этот аргумент равен NULL, то поток создается с атрибутами по умолчанию.

Чтобы подключить библиотеку Pthread к программе, нужно передать компоновщику опцию -lpthread

Поток завершает выполнение задачи когда:
потоковая функция выполняет return и возвращает результат произведенных вычислений;
в результате вызова завершения исполнения потока pthread_exit(); тут при выходе старшей нити из main 
с помощью этой штуки, остальные нити работают

в результате вызова отмены потока pthread_cancel();
одна из нитей совершает вызов exit()
основная нить в функции main() выполняет return, и в таком случае все нити процесса резко сворачиваются.


Функция pthread_join() ожидает завершения потока обозначенного THREAD_ID. 
Если этот поток к тому времени был уже завершен, то функция немедленно возвращает значение. 
Смысл функции в том, чтобы синхронизировать потоки.

int pthread_join (pthread_t THREAD_ID, void ** DATA);
Если указатель DATA отличается от NULL, то туда помещаются данные, 
возвращаемые потоком через функцию pthread_exit() или через инструкцию return потоковой функции.
